package model

import (
	"encoding/json"
	"errors"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"time"
)

var (
	ErrInvalidHintIntent = errors.New("invalid hint intent")
	ErrNilBundleMetadata = errors.New("bundle metadata is nil")
)

// HintIntent is a set of hint intents
// its marshalled as an array of strings
type HintIntent uint8

const (
	HintContractAddress HintIntent = 1 << iota
	HintFunctionSelector
	HintLogs
	HintCallData
	HintHash
	HintSpecialLogs
	HintTxHash
	HintNone = 0
)

func GetAllHints() HintIntent {
	allHints := HintIntent(0)
	allHints.SetHint(HintContractAddress)
	allHints.SetHint(HintFunctionSelector)
	allHints.SetHint(HintLogs)
	allHints.SetHint(HintCallData)
	allHints.SetHint(HintTxHash)
	allHints.SetHint(HintHash)
	return allHints
}

func (b *HintIntent) SetHint(flag HintIntent) {
	*b = *b | flag
}

func (b *HintIntent) HasHint(flag HintIntent) bool {
	return *b&flag != 0
}

func (b HintIntent) MarshalJSON() ([]byte, error) {
	var arr []string
	if b.HasHint(HintContractAddress) {
		arr = append(arr, "contract_address")
	}
	if b.HasHint(HintFunctionSelector) {
		arr = append(arr, "function_selector")
	}
	if b.HasHint(HintLogs) {
		arr = append(arr, "logs")
	}
	if b.HasHint(HintCallData) {
		arr = append(arr, "calldata")
	}
	if b.HasHint(HintHash) {
		arr = append(arr, "hash")
	}
	if b.HasHint(HintSpecialLogs) {
		arr = append(arr, "special_logs")
	}
	if b.HasHint(HintTxHash) {
		arr = append(arr, "tx_hash")
	}
	return json.Marshal(arr)
}

func (b *HintIntent) UnmarshalJSON(data []byte) error {
	var arr []string
	if err := json.Unmarshal(data, &arr); err != nil {
		return err
	}
	for _, v := range arr {
		switch v {
		case "contract_address":
			b.SetHint(HintContractAddress)
		case "function_selector":
			b.SetHint(HintFunctionSelector)
		case "logs":
			b.SetHint(HintLogs)
		case "calldata":
			b.SetHint(HintCallData)
		case "hash":
			b.SetHint(HintHash)
		case "special_logs", "default_logs":
			b.SetHint(HintSpecialLogs)
		case "tx_hash":
			b.SetHint(HintTxHash)
		default:
			return ErrInvalidHintIntent
		}
	}
	return nil
}

type SendMevBundleArgs struct {
	UserId          int                `json:"userId"`
	Version         string             `json:"version"`
	ReplacementUUID string             `json:"replacementUuid,omitempty"`
	Inclusion       MevBundleInclusion `json:"inclusion"`
	Body            []MevBundleBody    `json:"body"`
	Validity        MevBundleValidity  `json:"validity"`
	Privacy         *MevBundlePrivacy  `json:"privacy,omitempty"`
	Metadata        *MevBundleMetadata `json:"metadata,omitempty"`
	ArrivalTime     time.Time          `json:"-"`
}

type ReplacementData struct {
	ReplacementUUID  string `json:"replacementUuid"`
	ReplacementNonce uint64 `json:"replacementNonce"`
	Cancelled        bool   `json:"cancelled"`
}

type MevBundleInclusion struct {
	BlockNumber hexutil.Uint64 `json:"block"`
	MaxBlock    hexutil.Uint64 `json:"maxBlock"`
}

type MevBundleBody struct {
	Hash       *common.Hash       `json:"hash,omitempty"`
	Tx         *hexutil.Bytes     `json:"tx,omitempty"`
	Bundle     *SendMevBundleArgs `json:"bundle,omitempty"`
	CanRevert  bool               `json:"canRevert,omitempty"`
	RevertMode string             `json:"revertMode,omitempty"`
}

type MevBundleValidity struct {
	// specified by the original party (eg. user) who sends an input to MEV-Share
	Refund []RefundConstraint `json:"refund,omitempty"`
	// The refund is set by the MEV-Share Node
	RefundConfig []RefundConfig `json:"refundConfig,omitempty"`
}

type RefundConstraint struct {
	// Index of the entry in body to which the refund percentage applies.
	BodyIdx int `json:"bodyIdx"`
	// Minimum refund percentage required for this bundle to be eligible for use by another searcher, paid by said searcher from the profit generated by including this bundle in theirs.
	Percent int `json:"percent"`
}

type RefundConfig struct {
	Address common.Address `json:"address"`
	Percent int            `json:"percent"`
}

type MevBundlePrivacy struct {
	Hints      HintIntent `json:"hints,omitempty"`
	Builders   []string   `json:"builders,omitempty"`
	WantRefund *int       `json:"wantRefund,omitempty"`
}

type MevBundleMetadata struct {
	BundleHash       common.Hash    `json:"bundleHash,omitempty"`
	BodyHashes       []common.Hash  `json:"bodyHashes,omitempty"`
	Signer           common.Address `json:"signer,omitempty"`
	OriginID         string         `json:"originId,omitempty"`
	ReceivedAt       hexutil.Uint64 `json:"receivedAt,omitempty"`
	MatchingHash     common.Hash    `json:"matchingHash,omitempty"`
	Prematched       bool           `json:"prematched"`
	ReplacementNonce uint64         `json:"replacementNonce,omitempty"`
	Cancelled        bool           `json:"cancelled"`
}

type SendMevBundleResponse struct {
	// Hash of the list of bundle bodies defined by bundle composition.
	// If there is only one bundle in the list, the bundleHash returns the hash of that bundle body.
	BundleHash common.Hash `json:"bundleHash"`
}

type ResetHeaderArgs struct {
	HeaderNumber uint64
	Time         uint64
}

type ResetHeaderResponse struct {
	HeaderNumber uint64 `json:"headerNumber"`
}
